import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import numpy as np

def animate_bouncing_balls(r, g, b, radius, initial_velocity, box_size, boundary_size, line_thickness, cor, rows, cols, spacing, gravity):
    if radius * 2 > box_size:
        raise ValueError("Ball radius is too large for the given box size.")
    
    fig, ax = plt.subplots()
    ax.set_xlim(0, boundary_size)
    ax.set_ylim(0, boundary_size)
    
    margin = (boundary_size - box_size) / 2
    actual_line_thickness = (50 * line_thickness) / 2

    # Draw the enclosed box
    ax.plot([margin, margin], [margin, margin + box_size], 'k-', lw=actual_line_thickness)
    ax.plot([margin, margin + box_size], [margin + box_size, margin + box_size], 'k-', lw=actual_line_thickness)
    ax.plot([margin + box_size, margin + box_size], [margin + box_size, margin], 'k-', lw=actual_line_thickness)
    ax.plot([margin + box_size, margin], [margin, margin], 'k-', lw=actual_line_thickness)
    
    # Calculate initial positions for the grid of balls
    start_x = margin + radius + (box_size - (cols - 1) * spacing) / 2
    start_y = margin + radius + (box_size - (rows - 1) * spacing) / 2
    
    balls = []
    velocities = []
    
    for i in range(rows):
        for j in range(cols):
            x = start_x + j * spacing
            y = start_y + i * spacing
            ball = plt.Circle((x, y), radius, color=(r, g, b), lw=0)
            ax.add_patch(ball)
            balls.append(ball)
            velocities.append(list(initial_velocity))
    
    dt = 0.05
    repulsion_strength = -0.1  # Adjust this value to control repulsion strength
    
    def update(frame):
        # Calculate repulsive forces between all pairs of particles
        forces = [[0.0, 0.0] for _ in range(len(balls))]
        
        for i in range(len(balls)):
            for j in range(i + 1, len(balls)):
                pos_i = np.array(balls[i].center)
                pos_j = np.array(balls[j].center)
                
                # Calculate distance and direction
                diff = pos_j - pos_i
                distance = np.linalg.norm(diff)
                
                # Avoid division by zero and ensure minimum distance
                if distance < 2 * radius:
                    distance = 2 * radius
                
                # Calculate repulsive force (inverse square law)
                force_magnitude = repulsion_strength / (distance ** 2)
                force = force_magnitude * (diff / distance)
                
                # Apply forces (equal and opposite)
                forces[i][0] += force[0]
                forces[i][1] += force[1]
                forces[j][0] -= force[0]
                forces[j][1] -= force[1]
        
        # Update positions and velocities
        for idx, ball in enumerate(balls):
            position_x, position_y = ball.center
            velocity_x, velocity_y = velocities[idx]
            
            # Update velocity with gravity and repulsive forces
            velocity_y -= gravity * dt
            velocity_x += forces[idx][0] * dt
            velocity_y += forces[idx][1] * dt
            
            # Add some damping to help reach equilibrium
            velocity_x *= 0.99
            velocity_y *= 0.99
            
            # Update position based on velocity
            position_x += velocity_x * dt
            position_y += velocity_y * dt
            
            # Collision detection with walls
            if position_x - radius - line_thickness <= margin:
                position_x = margin + radius + line_thickness
                velocity_x = -velocity_x * cor
            elif position_x + radius + line_thickness >= margin + box_size:
                position_x = margin + box_size - radius - line_thickness
                velocity_x = -velocity_x * cor
            
            if position_y - radius - line_thickness <= margin:
                position_y = margin + radius + line_thickness
                velocity_y = -velocity_y * cor
            elif position_y + radius + line_thickness >= margin + box_size:
                position_y = margin + box_size - radius - line_thickness
                velocity_y = -velocity_y * cor
            
            ball.set_center((position_x, position_y))
            velocities[idx] = [velocity_x, velocity_y]
        
        return balls
    
    ani = FuncAnimation(fig, update, frames=300, interval=50, blit=True)
    plt.show()

# Run with your parameters
animate_bouncing_balls(0.8, 0.1, 0.3, 0.1, (0, 0), 10, 15, 0.1, 0.9, 10, 10, 0.1, 9.81)
